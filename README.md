[java技术驿站](http://cmsblogs.com/?cat=15)
[炸斯特](https://blog.csdn.net/jason0539/article/details/44956775)
# DesignMode
## **1.策略模式(Strategy开闭原则)**
#### **背景**
在软件开发中常常遇到这种情况，实现某一个功能有多种算法或者策略，我们可以根据环境或者条件的不同选择不同的算法或者策略来完成该功能.
#### **组成**
* 环境类(Context):用一个ConcreteStrategy对象来配置。维护一个对Strategy对象的引用。可定义一个接口来让Strategy访问它的数据。
* 抽象策略类(Strategy):定义所有支持的算法的公共接口。 Context使用这个接口来调用某ConcreteStrategy定义的算法。
* 具体策略类(ConcreteStrategy):以Strategy接口实现某具体算法。
## **2.装饰者模式(Decorator)**
#### **参与者**
* Component: 抽象构件。是定义一个对象接口，可以给这些对象动态地添加职责。
* ConcreteComponent:具体构件。是定义了一个具体的对象，也可以给这个对象添加一些职责。
* Decorator: 抽象装饰类。是装饰抽象类，继承了Component,从外类来扩展Component类的功能，但对于Component来说，是无需知道Decorator存在的。
* ConcreteDecorator:具体装饰类，起到给Component添加职责的功能。
## **3.门面模式(Facade)**
##### **参与者**
* Facade: 外观角色。客户端可以调用这个角色的方法。知道哪些子系统类负责处理请求，将客户的请求代理给适合的子系统处理。
* SubSystem:子系统角色。实现子系统功能，处理Facade对象发来的请求。可以同时有一个或者多个子系统。每个子系统都不是一个单独的类，而是一个类的集合
（如上面的子系统就是由ModuleA、ModuleB、ModuleC三个类组合而成）。每个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。
## **4.模版模式(Template)**
#### **参与者**
* AbstractClass: 抽象类。实现了一个模板，实现算法的基本骨架，具体子类将重定义primitiveOperation()方法以实现一个算法步骤。
* ConcreteClass:  具体子类。实现primitiveOperation()方法以完成算法中与特定子类相关的步骤。
## **5.观察者模式(Observer)**
#### **角色**
* 抽象被观察者：把所有对观察者对象的引用保存在一个集合中，每个被观察者角色都可以有任意数量的观察者。被观察者提供一个接口，可以增加和删除观察者角色。一般用一个抽象类和接口来实现。
* 抽象观察者：为所有具体的观察者定义一个接口，在得到主题的通知时更新自己。
* 具体被观察者：在被观察者内部状态改变时，给所有登记过的观察者发出通知。具体被观察者角色通常用一个子类实现。
* 具体观察者：该角色实现抽象观察者角色所要求的更新接口，以便使本身的状态与主题的状态相协调。通常用一个子类实现。如果需要，具体观察者角色可以保存一个指向具体主题角色的引用。
## **6.中介者模式(Mediator)**
#### **角色**
* Mediator: 抽象中介者。定义了同事对象到中介者对象之间的接口。
* ConcreteMediator: 具体中介者。实现抽象中介者的方法，它需要知道所有的具体同事类，同时需要从具体的同事类那里接收信息，并且向具体的同事类发送信息。
* Colleague: 抽象同事类。
* ConcreteColleague: 具体同事类。每个具体同事类都只需要知道自己的行为即可，但是他们都需要认识中介者。
## **6.解释器模式(Interpreter) /ɪn'tɜːprɪtə/**
#### **角色**
* AbstractExpression: 抽象表达式。声明一个抽象的解释操作，该接口为抽象语法树中所有的节点共享。
* TerminalExpression: 终结符表达式。实现与文法中的终结符相关的解释操作。实现抽象表达式中所要求的方法。文法中每一个终结符都有一个具体的终结表达式与之相对应。
* NonterminalExpression: 非终结符表达式。为文法中的非终结符相关的解释操作。
* Context: 环境类。包含解释器之外的一些全局信息。
* Client: 客户类。
抽象语法树描述了如何构成一个复杂的句子，通过对抽象语法树的分析，可以识别出语言中的终结符和非终结符类。 在解释器模式中由于每一种终结符表达式、非终结符表达式都会有一个具体的实例与之相对应，所以系统的扩展性比较好。